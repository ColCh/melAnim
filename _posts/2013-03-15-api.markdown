---
layout: default
title: Описание API
category: Описание библиотеки
---
Use numbered headers: true

Все методы и свойства описаны в коде с помощью *JSDOC*.
На этой странице будут описаны только основные экспортируемые классы и функции, их методы и аргументы.
{: .lead}

# Содержание #

* table of contents
{:toc}

# animate #

Функция для процедурного анимирования элементов - т.е. без создания экземпляров, в один вызов.

# Animation #

Основной класс-строитель для создания экзепляров.

*[класс-строитель]: Паттерн Builder

# CSSAnimation #

Конструктор анимаций с использованием графического ускорителя - *CSS3 Animation*.

# ClassicAnimation #

Конструктор *JavaScript*-анимаций - реализация стандарта *CSS3* анимаций на *JavaScript*.

# vendorize #

Функция попытается подобрать вендорный префикс к свойству, применяя при этом преобразование имени свойства из CSS-формата в DOM-формат.

Возвращаемое значение - верное имя свойства, или `null`, если подобрать не удалось.

*[CSS-формата]: Слова в свойстве разделени дефисом. Пр. : "z-index"
*[DOM-формат]: Слова в свойстве пишутся с большой буквы без разделителей. Пр. : "zIndex"

## Формат аргументов ##

{% highlight javascript %}
    function vendorize(propertyName, target);
{% endhighlight %}

Где: 

`propertyName`
:имя свойства

`target`
:Где смотреть наличие свойств - в *CSS* при `false`, в *window* при `true`, или в переданном объекте Тип - `Boolean` или `Object`.

## Примеры использования ##

{% highlight javascript %}
    // вернёт performance в Chrome
    melAnim.vendorize("performance", true);

    // вернёт webkitNow в Chrome
    melAnim.vendorize("now", window.performance);
    
    // вернёт text-shadow в Chrome
    melAnim.vendorize("text-shadow", false);
{% endhighlight %}

# beforeReflow #

Исполнит функцию перед следующей отрисовкой. Если браузер не имеет встроенной реализации `requestAnimationFrame`, то будет использован 
таймер отрисовки на `window.setTimeout` - один для всех обработчиков.
Экспортируется для совместного использования таймера отрисовки как `melAnim`, так и любого другого кода.

## Формат аргументов ##

{% highlight javascript %}
    function beforeReflow(callback);
{% endhighlight %}

Где: 

`callback`
:функция, которая исполнится перед отрисовкой. Ей будет передано первым аргументом текущее время в формате *timestamp*.

## Примеры использования ##

{% highlight javascript %}
    melAnim.beforeReflow(function (timestamp) {
        alert( timestamp ); // выведет текущее время
    });
{% endhighlight %}

# css #

Установит значение стиля элементу, либо получит текущее значение свойства из вычисленного стиля, если опустить передачу значения свойства.
Лучше всего эту функцию использовать совместно с `normalize`.

## Формат аргументов : ##

{% highlight javascript %}
    function css(element, propertyName [, propertyValue])
{% endhighlight %}

Где: 

`element`
:объект, с которым функция будет работать. Тип : `HTMLElement` или `CSSStyleDeclaration`

`propertyName`
:имя свойства, с которым функция будет работать. Тип - `String` (строка).

`propertyValue`
:значение свойства. Необязательный аргумент. Его передача переводит `css` из режима получения значения в режим установки свойства. Тип - `Number`, или `String`, или `Array`.

## Примеры использования ##

{% highlight javascript %}
    // установит <body> красный цвет текста
    css(document.body, "color", "red");

    // установит переданному стилю размер шрифта, равный 20 пикселям
    css(document.body.style, "font-size", "20px");
    
    // и так далее, по аналогии
{% endhighlight %}

## Пример хука ##

{% highlight javascript %}
    // установка величины прокрутки с помощью css
    melAnim.hooks [ "scrollTop" ] [ "set" ] = function (element, propertyName, propertyValue) {
        element.scrollTop = propertyValue;
    };
    
    // получение значения кастомного свойства "myProp"
    melAnim.hooks [ "myProp" ] [ "get" ] = function (element, propertyName, propertyValue) {
        // что здесь будет находиться, определит ваша фантазия :)
        element.style.borderWidth = propertyValue;
    };
{% endhighlight %}

# normalize #

Преобразует строкое представление значения в машино-читабельное или наоборот.
Передача элемента необходима для трансляции в другой тип значения - к примеру, из процентов и пиксели.

{% highlight javascript %}
    function normalize(element, propertyName, propertyValue, toString)
{% endhighlight %}

Где: 

`element`
:объект, с которым функция будет работать. Тип : `HTMLElement` или `CSSStyleDeclaration`

`propertyName`
:имя свойства, с которым функция будет работать. Тип - `String` (строка).

`propertyValue`
:значение свойства. Тип - `Number`, или `String`, или `Array`.

`toString`
:определяет поведение. Если передано значение `true`, то функция приведёт числовое значение в строковое, и если `false` - то в числовое. Тип - `Boolean`.

## Пример использования ##

{% highlight javascript %}
    // формат по-умолчанию установлен "PX"

    // переведёт проценты в числовое значение
    normalize(document.body, "width", "50%", false); // 960
    
    // и приведёт числовое значение в строку
    normalize(document.body, "width", 960, true); // "960px"
{% endhighlight %}

## Пример хука ##

{% highlight javascript %}
    // хук для значения прокрутки
    melAnim.hooks[ "scrollTop" ] ['normalize'] = function (element, propertyName, propertyValue, toString) {
        return element.scrollTop;
    };
    
    // хук для перевода значения матрицы 2D трансформации
    melAnim.hooks[ "transform" ] ['normalize'] = function (element, propertyName, propertyValue, toString) {
        if (toString) {
            return "matrix(" + propertyValue.join(", ") + ")";
        } else {
            return propertyValue.match(/matrix\(([^\)]+)\)/).split(",").map(function (x) { return parseInt(x, 10); });
        }
    };
{% endhighlight %}

*[машино-читабельное]: Численное значение, с которым можно оперировать